import { EventEmitter, Inject, Injectable } from '@angular/core';
import { connect, MqttClient } from 'mqtt-browser';
import * as extend from 'xtend';
import { BehaviorSubject, merge, Observable, Subject, Subscription, using } from 'rxjs';
import { filter, publish, publishReplay, refCount } from 'rxjs/operators';
import { MqttConnectionState } from './mqtt.model';
import { MqttClientService, MqttServiceConfig } from './mqtt.module';
import * as i0 from "@angular/core";
import * as i1 from "./mqtt.module";
/**
 * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,
 * to only subscribe to the broker once per MQTT filter.
 * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.
 */
export class MqttService {
    /**
     * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some
     * options to configure behavior of this service, like if the connection to the broker
     * should be established on creation of this service or not.
     */
    constructor(options, client) {
        this.options = options;
        this.client = client;
        /** a map of all mqtt observables by filter */
        this.observables = {};
        /** the connection state */
        this.state = new BehaviorSubject(MqttConnectionState.CLOSED);
        /** an observable of the last mqtt message */
        this.messages = new Subject();
        this._clientId = this._generateClientId();
        this._connectTimeout = 10000;
        this._reconnectPeriod = 10000;
        this._url = undefined;
        this._onConnect = new EventEmitter();
        this._onReconnect = new EventEmitter();
        this._onClose = new EventEmitter();
        this._onOffline = new EventEmitter();
        this._onError = new EventEmitter();
        this._onEnd = new EventEmitter();
        this._onMessage = new EventEmitter();
        this._onSuback = new EventEmitter();
        this._onPacketsend = new EventEmitter();
        this._onPacketreceive = new EventEmitter();
        this._handleOnConnect = (e) => {
            if (this.options.connectOnCreate === true) {
                Object.keys(this.observables).forEach((filterString) => {
                    this.client.subscribe(filterString);
                });
            }
            this.state.next(MqttConnectionState.CONNECTED);
            this._onConnect.emit(e);
        };
        this._handleOnReconnect = () => {
            if (this.options.connectOnCreate === true) {
                Object.keys(this.observables).forEach((filterString) => {
                    this.client.subscribe(filterString);
                });
            }
            this.state.next(MqttConnectionState.CONNECTING);
            this._onReconnect.emit();
        };
        this._handleOnClose = () => {
            this.state.next(MqttConnectionState.CLOSED);
            this._onClose.emit();
        };
        this._handleOnOffline = () => {
            this._onOffline.emit();
        };
        this._handleOnError = (e) => {
            this._onError.emit(e);
            console.error(e);
        };
        this._handleOnEnd = () => {
            this._onEnd.emit();
        };
        this._handleOnMessage = (topic, payload, packet) => {
            this._onMessage.emit(packet);
            if (packet.cmd === 'publish') {
                this.messages.next(packet);
            }
        };
        this._handleOnPacketsend = (e) => {
            this._onPacketsend.emit();
        };
        this._handleOnPacketreceive = (e) => {
            this._onPacketreceive.emit();
        };
        if (options.connectOnCreate !== false) {
            this.connect({}, client);
        }
        this.state.subscribe();
    }
    /**
     * gets the _clientId
     */
    get clientId() {
        return this._clientId;
    }
    /** An EventEmitter to listen to connect messages */
    get onConnect() {
        return this._onConnect;
    }
    /** An EventEmitter to listen to reconnect messages */
    get onReconnect() {
        return this._onReconnect;
    }
    /** An EventEmitter to listen to close messages */
    get onClose() {
        return this._onClose;
    }
    /** An EventEmitter to listen to offline events */
    get onOffline() {
        return this._onOffline;
    }
    /** An EventEmitter to listen to error events */
    get onError() {
        return this._onError;
    }
    /** An EventEmitter to listen to close messages */
    get onEnd() {
        return this._onEnd;
    }
    /** An EventEmitter to listen to message events */
    get onMessage() {
        return this._onMessage;
    }
    /** An EventEmitter to listen to packetsend messages */
    get onPacketsend() {
        return this._onPacketsend;
    }
    /** An EventEmitter to listen to packetreceive messages */
    get onPacketreceive() {
        return this._onPacketreceive;
    }
    /** An EventEmitter to listen to suback events */
    get onSuback() {
        return this._onSuback;
    }
    /**
     * This static method shall be used to determine whether a MQTT
     * topic matches a given filter. The matching rules are specified in the MQTT
     * standard documentation and in the library test suite.
     *
     * @param  {string}  filter A filter may contain wildcards like '#' and '+'.
     * @param  {string}  topic  A topic may not contain wildcards.
     * @return {boolean}        true on match and false otherwise.
     */
    static filterMatchesTopic(filterString, topic) {
        if (filterString[0] === '#' && topic[0] === '$') {
            return false;
        }
        // Preparation: split and reverse on '/'. The JavaScript split function is sane.
        const fs = (filterString || '').split('/').reverse();
        const ts = (topic || '').split('/').reverse();
        // This function is tail recursive and compares both arrays one element at a time.
        const match = () => {
            // Cutting of the last element of both the filter and the topic using pop().
            const f = fs.pop();
            const t = ts.pop();
            switch (f) {
                // In case the filter level is '#', this is a match no matter whether
                // the topic is undefined on this level or not ('#' matches parent element as well!).
                case '#':
                    return true;
                // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.
                case '+':
                    return t ? match() : false;
                // In all other cases the filter level must match the topic level,
                // both must be defined and the filter tail must match the topic
                // tail (which is determined by the recursive call of match()).
                default:
                    return f === t && (f === undefined ? true : match());
            }
        };
        return match();
    }
    /**
     * connect manually connects to the mqtt broker.
     */
    connect(opts, client) {
        const options = extend(this.options || {}, opts);
        const protocol = options.protocol || 'ws';
        const hostname = options.hostname || 'localhost';
        if (options.url) {
            this._url = options.url;
        }
        else {
            this._url = `${protocol}://${hostname}`;
            this._url += options.port ? `:${options.port}` : '';
            this._url += options.path ? `${options.path}` : '';
        }
        this.state.next(MqttConnectionState.CONNECTING);
        const mergedOptions = extend({
            clientId: this._clientId,
            reconnectPeriod: this._reconnectPeriod,
            connectTimeout: this._connectTimeout
        }, options);
        if (this.client) {
            this.client.end(true);
        }
        if (!client) {
            this.client = connect(this._url, mergedOptions);
        }
        else {
            this.client = client;
        }
        this._clientId = mergedOptions.clientId;
        this.client.on('connect', this._handleOnConnect);
        this.client.on('reconnect', this._handleOnReconnect);
        this.client.on('close', this._handleOnClose);
        this.client.on('offline', this._handleOnOffline);
        this.client.on('error', this._handleOnError);
        this.client.stream.on('error', this._handleOnError);
        this.client.on('end', this._handleOnEnd);
        this.client.on('message', this._handleOnMessage);
        this.client.on('packetsend', this._handleOnPacketsend);
        this.client.on('packetreceive', this._handleOnPacketreceive);
    }
    /**
     * disconnect disconnects from the mqtt client.
     * This method `should` be executed when leaving the application.
     */
    disconnect(force = true) {
        if (!this.client) {
            throw new Error('mqtt client not connected');
        }
        this.client.end(force);
    }
    /**
     * With this method, you can observe messages for a mqtt topic.
     * The observable will only emit messages matching the filter.
     * The first one subscribing to the resulting observable executes a mqtt subscribe.
     * The last one unsubscribing this filter executes a mqtt unsubscribe.
     * Every new subscriber gets the latest message.
     */
    observeRetained(filterString, opts = { qos: 1 }) {
        return this._generalObserve(filterString, () => publishReplay(1), opts);
    }
    /**
     * With this method, you can observe messages for a mqtt topic.
     * The observable will only emit messages matching the filter.
     * The first one subscribing to the resulting observable executes a mqtt subscribe.
     * The last one unsubscribing this filter executes a mqtt unsubscribe.
     */
    observe(filterString, opts = { qos: 1 }) {
        return this._generalObserve(filterString, () => publish(), opts);
    }
    /**
     * With this method, you can observe messages for a mqtt topic.
     * The observable will only emit messages matching the filter.
     * The first one subscribing to the resulting observable executes a mqtt subscribe.
     * The last one unsubscribing this filter executes a mqtt unsubscribe.
     * Depending on the publish function, the messages will either be replayed after new
     * subscribers subscribe or the messages are just passed through
     */
    _generalObserve(filterString, publishFn, opts) {
        if (!this.client) {
            throw new Error('mqtt client not connected');
        }
        if (!this.observables[filterString]) {
            const rejected = new Subject();
            this.observables[filterString] = using(
            // resourceFactory: Do the actual ref-counting MQTT subscription.
            // refcount is decreased on unsubscribe.
            () => {
                const subscription = new Subscription();
                this.client.subscribe(filterString, opts, (err, granted) => {
                    if (granted) { // granted can be undefined when an error occurs when the client is disconnecting
                        granted.forEach((granted_) => {
                            if (granted_.qos === 128) {
                                delete this.observables[granted_.topic];
                                this.client.unsubscribe(granted_.topic);
                                rejected.error(`subscription for '${granted_.topic}' rejected!`);
                            }
                            this._onSuback.emit({ filter: filterString, granted: granted_.qos !== 128 });
                        });
                    }
                });
                subscription.add(() => {
                    delete this.observables[filterString];
                    this.client.unsubscribe(filterString);
                });
                return subscription;
            }, 
            // observableFactory: Create the observable that is consumed from.
            // This part is not executed until the Observable returned by
            // `observe` gets actually subscribed.
            (subscription) => merge(rejected, this.messages))
                .pipe(filter((msg) => MqttService.filterMatchesTopic(filterString, msg.topic)), publishFn(), refCount());
        }
        return this.observables[filterString];
    }
    /**
     * This method returns an observable for a topic with optional options.
     * After subscribing, the actual mqtt publication will be executed and
     * the observable will emit an empty value and completes, if publishing was successful
     * or throws an error, if the publication fails.
     */
    publish(topic, message, options = {}) {
        if (!this.client) {
            throw new Error('mqtt client not connected');
        }
        return Observable.create((obs) => {
            this.client.publish(topic, message, options, (error) => {
                if (error) {
                    obs.error(error);
                }
                else {
                    obs.next(null);
                    obs.complete();
                }
            });
        });
    }
    /**
     * This method publishes a message for a topic with optional options.
     * If an error occurs, it will throw.
     */
    unsafePublish(topic, message, options = {}) {
        if (!this.client) {
            throw new Error('mqtt client not connected');
        }
        this.client.publish(topic, message, options, (error) => {
            if (error) {
                throw (error);
            }
        });
    }
    _generateClientId() {
        return 'client-' + Math.random().toString(36).substr(2, 19);
    }
}
MqttService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MqttService_Factory() { return new MqttService(i0.ɵɵinject(i1.MqttServiceConfig), i0.ɵɵinject(i1.MqttClientService)); }, token: MqttService, providedIn: "root" });
MqttService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
MqttService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MqttServiceConfig,] }] },
    { type: MqttClient, decorators: [{ type: Inject, args: [MqttClientService,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXF0dC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LW1xdHQvc3JjL2xpYi9tcXR0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFlBQVksRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQy9ELE9BQU8sRUFBRSxPQUFPLEVBQXNFLFVBQVUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUV2SCxPQUFPLEtBQUssTUFBTSxNQUFNLE9BQU8sQ0FBQztBQUVoQyxPQUFPLEVBQUMsZUFBZSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQVksT0FBTyxFQUFFLFlBQVksRUFBa0IsS0FBSyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ2hILE9BQU8sRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4RSxPQUFPLEVBU0wsbUJBQW1CLEVBQ3BCLE1BQU0sY0FBYyxDQUFDO0FBRXRCLE9BQU8sRUFBQyxpQkFBaUIsRUFBRSxpQkFBaUIsRUFBQyxNQUFNLGVBQWUsQ0FBQzs7O0FBRW5FOzs7O0dBSUc7QUFJSCxNQUFNLE9BQU8sV0FBVztJQUV0Qjs7OztPQUlHO0lBQ0gsWUFDcUMsT0FBNEIsRUFDNUIsTUFBbUI7UUFEbkIsWUFBTyxHQUFQLE9BQU8sQ0FBcUI7UUFDNUIsV0FBTSxHQUFOLE1BQU0sQ0FBYTtRQWlFeEQsOENBQThDO1FBQ3ZDLGdCQUFXLEdBQXlELEVBQUUsQ0FBQztRQUM5RSwyQkFBMkI7UUFDcEIsVUFBSyxHQUFpQyxJQUFJLGVBQWUsQ0FBc0IsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbEgsNkNBQTZDO1FBQ3RDLGFBQVEsR0FBMEIsSUFBSSxPQUFPLEVBQWdCLENBQUM7UUFFN0QsY0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FB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QUFHLENBQUMsUUFBUSxFQUFFLENBQUM7aUJBQ2hCO1lBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSSxhQUFhLENBQUMsS0FBYSxFQUFFLE9BQXdCLEVBQUUsVUFBMkIsRUFBRTtRQUN6RixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUM7UUFDRCxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQXNCLEVBQUUsRUFBRTtZQUN0RSxJQUFJLEtBQUssRUFBRTtnQkFDVCxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDZjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQXVETyxpQkFBaUI7UUFDdkIsT0FBTyxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzlELENBQUM7Ozs7WUFyV0YsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7NENBU0ksTUFBTSxTQUFDLGlCQUFpQjtZQXJDeUQsVUFBVSx1QkFzQzNGLE1BQU0sU0FBQyxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0V2ZW50RW1pdHRlciwgSW5qZWN0LCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNvbm5lY3QsIElDbGllbnRQdWJsaXNoT3B0aW9ucywgSUNsaWVudFN1YnNjcmliZU9wdGlvbnMsIElTdWJzY3JpcHRpb25HcmFudCwgTXF0dENsaWVudCB9IGZyb20gJ21xdHQtYnJvd3Nlcic7XG5pbXBvcnQgeyBQYWNrZXQgfSBmcm9tICdtcXR0LXBhY2tldCc7XG5pbXBvcnQgKiBhcyBleHRlbmQgZnJvbSAneHRlbmQnO1xuXG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgbWVyZ2UsIE9ic2VydmFibGUsIE9ic2VydmVyLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24sIFVuc3Vic2NyaWJhYmxlLCB1c2luZ30gZnJvbSAncnhqcyc7XG5pbXBvcnQge2ZpbHRlciwgcHVibGlzaCwgcHVibGlzaFJlcGxheSwgcmVmQ291bnR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtcbiAgSU1xdHRNZXNzYWdlLFxuICBJTXF0dFNlcnZpY2VPcHRpb25zLFxuICBJT25Db25uZWN0RXZlbnQsXG4gIElPbkVycm9yRXZlbnQsXG4gIElPblBhY2tldHJlY2VpdmVFdmVudCxcbiAgSU9uUGFja2V0c2VuZEV2ZW50LFxuICBJT25TdWJhY2tFdmVudCxcbiAgSVB1Ymxpc2hPcHRpb25zLFxuICBNcXR0Q29ubmVjdGlvblN0YXRlXG59IGZyb20gJy4vbXF0dC5tb2RlbCc7XG5cbmltcG9ydCB7TXF0dENsaWVudFNlcnZpY2UsIE1xdHRTZXJ2aWNlQ29uZmlnfSBmcm9tICcuL21xdHQubW9kdWxlJztcblxuLyoqXG4gKiBXaXRoIGFuIGluc3RhbmNlIG9mIE1xdHRTZXJ2aWNlLCB5b3UgY2FuIG9ic2VydmUgYW5kIHN1YnNjcmliZSB0byBNUVRUIGluIG11bHRpcGxlIHBsYWNlcywgZS5nLiBpbiBkaWZmZXJlbnQgY29tcG9uZW50cyxcbiAqIHRvIG9ubHkgc3Vic2NyaWJlIHRvIHRoZSBicm9rZXIgb25jZSBwZXIgTVFUVCBmaWx0ZXIuXG4gKiBJdCBhbHNvIGhhbmRsZXMgcHJvcGVyIHVuc3Vic2NyaXB0aW9uIGZyb20gdGhlIGJyb2tlciwgaWYgdGhlIGxhc3Qgb2JzZXJ2YWJsZSB3aXRoIGEgZmlsdGVyIGlzIGNsb3NlZC5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIE1xdHRTZXJ2aWNlIHtcblxuICAvKipcbiAgICogVGhlIGNvbnN0cnVjdG9yIG5lZWRzIFtjb25uZWN0aW9uIG9wdGlvbnNde0BsaW5rIElNcXR0U2VydmljZU9wdGlvbnN9IHJlZ2FyZGluZyB0aGUgYnJva2VyIGFuZCBzb21lXG4gICAqIG9wdGlvbnMgdG8gY29uZmlndXJlIGJlaGF2aW9yIG9mIHRoaXMgc2VydmljZSwgbGlrZSBpZiB0aGUgY29ubmVjdGlvbiB0byB0aGUgYnJva2VyXG4gICAqIHNob3VsZCBiZSBlc3RhYmxpc2hlZCBvbiBjcmVhdGlvbiBvZiB0aGlzIHNlcnZpY2Ugb3Igbm90LlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChNcXR0U2VydmljZUNvbmZpZykgcHJpdmF0ZSBvcHRpb25zOiBJTXF0dFNlcnZpY2VPcHRpb25zLFxuICAgIEBJbmplY3QoTXF0dENsaWVudFNlcnZpY2UpIHByaXZhdGUgY2xpZW50PzogTXF0dENsaWVudFxuICApIHtcbiAgICBpZiAob3B0aW9ucy5jb25uZWN0T25DcmVhdGUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmNvbm5lY3Qoe30sIGNsaWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRzIHRoZSBfY2xpZW50SWRcbiAgICovXG4gIHB1YmxpYyBnZXQgY2xpZW50SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudElkO1xuICB9XG5cbiAgLyoqIEFuIEV2ZW50RW1pdHRlciB0byBsaXN0ZW4gdG8gY29ubmVjdCBtZXNzYWdlcyAqL1xuICBwdWJsaWMgZ2V0IG9uQ29ubmVjdCgpOiBFdmVudEVtaXR0ZXI8SU9uQ29ubmVjdEV2ZW50PiB7XG4gICAgcmV0dXJuIHRoaXMuX29uQ29ubmVjdDtcbiAgfVxuXG4gIC8qKiBBbiBFdmVudEVtaXR0ZXIgdG8gbGlzdGVuIHRvIHJlY29ubmVjdCBtZXNzYWdlcyAqL1xuICBwdWJsaWMgZ2V0IG9uUmVjb25uZWN0KCk6IEV2ZW50RW1pdHRlcjx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX29uUmVjb25uZWN0O1xuICB9XG5cbiAgLyoqIEFuIEV2ZW50RW1pdHRlciB0byBsaXN0ZW4gdG8gY2xvc2UgbWVzc2FnZXMgKi9cbiAgcHVibGljIGdldCBvbkNsb3NlKCk6IEV2ZW50RW1pdHRlcjx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX29uQ2xvc2U7XG4gIH1cblxuICAvKiogQW4gRXZlbnRFbWl0dGVyIHRvIGxpc3RlbiB0byBvZmZsaW5lIGV2ZW50cyAqL1xuICBwdWJsaWMgZ2V0IG9uT2ZmbGluZSgpOiBFdmVudEVtaXR0ZXI8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9vbk9mZmxpbmU7XG4gIH1cblxuICAvKiogQW4gRXZlbnRFbWl0dGVyIHRvIGxpc3RlbiB0byBlcnJvciBldmVudHMgKi9cbiAgcHVibGljIGdldCBvbkVycm9yKCk6IEV2ZW50RW1pdHRlcjxJT25FcnJvckV2ZW50PiB7XG4gICAgcmV0dXJuIHRoaXMuX29uRXJyb3I7XG4gIH1cblxuICAvKiogQW4gRXZlbnRFbWl0dGVyIHRvIGxpc3RlbiB0byBjbG9zZSBtZXNzYWdlcyAqL1xuICBwdWJsaWMgZ2V0IG9uRW5kKCk6IEV2ZW50RW1pdHRlcjx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX29uRW5kO1xuICB9XG5cbiAgLyoqIEFuIEV2ZW50RW1pdHRlciB0byBsaXN0ZW4gdG8gbWVzc2FnZSBldmVudHMgKi9cbiAgcHVibGljIGdldCBvbk1lc3NhZ2UoKTogRXZlbnRFbWl0dGVyPFBhY2tldD4ge1xuICAgIHJldHVybiB0aGlzLl9vbk1lc3NhZ2U7XG4gIH1cblxuICAvKiogQW4gRXZlbnRFbWl0dGVyIHRvIGxpc3RlbiB0byBwYWNrZXRzZW5kIG1lc3NhZ2VzICovXG4gIHB1YmxpYyBnZXQgb25QYWNrZXRzZW5kKCk6IEV2ZW50RW1pdHRlcjxJT25QYWNrZXRzZW5kRXZlbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5fb25QYWNrZXRzZW5kO1xuICB9XG5cbiAgLyoqIEFuIEV2ZW50RW1pdHRlciB0byBsaXN0ZW4gdG8gcGFja2V0cmVjZWl2ZSBtZXNzYWdlcyAqL1xuICBwdWJsaWMgZ2V0IG9uUGFja2V0cmVjZWl2ZSgpOiBFdmVudEVtaXR0ZXI8SU9uUGFja2V0cmVjZWl2ZUV2ZW50PiB7XG4gICAgcmV0dXJuIHRoaXMuX29uUGFja2V0cmVjZWl2ZTtcbiAgfVxuXG4gIC8qKiBBbiBFdmVudEVtaXR0ZXIgdG8gbGlzdGVuIHRvIHN1YmFjayBldmVudHMgKi9cbiAgcHVibGljIGdldCBvblN1YmFjaygpOiBFdmVudEVtaXR0ZXI8SU9uU3ViYWNrRXZlbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5fb25TdWJhY2s7XG4gIH1cbiAgLyoqIGEgbWFwIG9mIGFsbCBtcXR0IG9ic2VydmFibGVzIGJ5IGZpbHRlciAqL1xuICBwdWJsaWMgb2JzZXJ2YWJsZXM6IHsgW2ZpbHRlclN0cmluZzogc3RyaW5nXTogT2JzZXJ2YWJsZTxJTXF0dE1lc3NhZ2U+IH0gPSB7fTtcbiAgLyoqIHRoZSBjb25uZWN0aW9uIHN0YXRlICovXG4gIHB1YmxpYyBzdGF0ZTogU3ViamVjdDxNcXR0Q29ubmVjdGlvblN0YXRlPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TXF0dENvbm5lY3Rpb25TdGF0ZT4oTXF0dENvbm5lY3Rpb25TdGF0ZS5DTE9TRUQpO1xuICAvKiogYW4gb2JzZXJ2YWJsZSBvZiB0aGUgbGFzdCBtcXR0IG1lc3NhZ2UgKi9cbiAgcHVibGljIG1lc3NhZ2VzOiBTdWJqZWN0PElNcXR0TWVzc2FnZT4gPSBuZXcgU3ViamVjdDxJTXF0dE1lc3NhZ2U+KCk7XG5cbiAgcHJpdmF0ZSBfY2xpZW50SWQgPSB0aGlzLl9nZW5lcmF0ZUNsaWVudElkKCk7XG4gIHByaXZhdGUgX2Nvbm5lY3RUaW1lb3V0ID0gMTAwMDA7XG4gIHByaXZhdGUgX3JlY29ubmVjdFBlcmlvZCA9IDEwMDAwO1xuICBwcml2YXRlIF91cmw6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIF9vbkNvbm5lY3Q6IEV2ZW50RW1pdHRlcjxJT25Db25uZWN0RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJT25Db25uZWN0RXZlbnQ+KCk7XG4gIHByaXZhdGUgX29uUmVjb25uZWN0OiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gIHByaXZhdGUgX29uQ2xvc2U6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgcHJpdmF0ZSBfb25PZmZsaW5lOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gIHByaXZhdGUgX29uRXJyb3I6IEV2ZW50RW1pdHRlcjxJT25FcnJvckV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU9uRXJyb3JFdmVudD4oKTtcbiAgcHJpdmF0ZSBfb25FbmQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgcHJpdmF0ZSBfb25NZXNzYWdlOiBFdmVudEVtaXR0ZXI8UGFja2V0PiA9IG5ldyBFdmVudEVtaXR0ZXI8UGFja2V0PigpO1xuICBwcml2YXRlIF9vblN1YmFjazogRXZlbnRFbWl0dGVyPElPblN1YmFja0V2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU9uU3ViYWNrRXZlbnQ+KCk7XG4gIHByaXZhdGUgX29uUGFja2V0c2VuZDogRXZlbnRFbWl0dGVyPElPblBhY2tldHNlbmRFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElPblBhY2tldHNlbmRFdmVudD4oKTtcbiAgcHJpdmF0ZSBfb25QYWNrZXRyZWNlaXZlOiBFdmVudEVtaXR0ZXI8SU9uUGFja2V0cmVjZWl2ZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU9uUGFja2V0cmVjZWl2ZUV2ZW50PigpO1xuXG4gIC8qKlxuICAgKiBUaGlzIHN0YXRpYyBtZXRob2Qgc2hhbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIE1RVFRcbiAgICogdG9waWMgbWF0Y2hlcyBhIGdpdmVuIGZpbHRlci4gVGhlIG1hdGNoaW5nIHJ1bGVzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIE1RVFRcbiAgICogc3RhbmRhcmQgZG9jdW1lbnRhdGlvbiBhbmQgaW4gdGhlIGxpYnJhcnkgdGVzdCBzdWl0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZmlsdGVyIEEgZmlsdGVyIG1heSBjb250YWluIHdpbGRjYXJkcyBsaWtlICcjJyBhbmQgJysnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0b3BpYyAgQSB0b3BpYyBtYXkgbm90IGNvbnRhaW4gd2lsZGNhcmRzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgdHJ1ZSBvbiBtYXRjaCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmaWx0ZXJNYXRjaGVzVG9waWMoZmlsdGVyU3RyaW5nOiBzdHJpbmcsIHRvcGljOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoZmlsdGVyU3RyaW5nWzBdID09PSAnIycgJiYgdG9waWNbMF0gPT09ICckJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBQcmVwYXJhdGlvbjogc3BsaXQgYW5kIHJldmVyc2Ugb24gJy8nLiBUaGUgSmF2YVNjcmlwdCBzcGxpdCBmdW5jdGlvbiBpcyBzYW5lLlxuICAgIGNvbnN0IGZzID0gKGZpbHRlclN0cmluZyB8fCAnJykuc3BsaXQoJy8nKS5yZXZlcnNlKCk7XG4gICAgY29uc3QgdHMgPSAodG9waWMgfHwgJycpLnNwbGl0KCcvJykucmV2ZXJzZSgpO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdGFpbCByZWN1cnNpdmUgYW5kIGNvbXBhcmVzIGJvdGggYXJyYXlzIG9uZSBlbGVtZW50IGF0IGEgdGltZS5cbiAgICBjb25zdCBtYXRjaCA9ICgpOiBib29sZWFuID0+IHtcbiAgICAgIC8vIEN1dHRpbmcgb2YgdGhlIGxhc3QgZWxlbWVudCBvZiBib3RoIHRoZSBmaWx0ZXIgYW5kIHRoZSB0b3BpYyB1c2luZyBwb3AoKS5cbiAgICAgIGNvbnN0IGYgPSBmcy5wb3AoKTtcbiAgICAgIGNvbnN0IHQgPSB0cy5wb3AoKTtcbiAgICAgIHN3aXRjaCAoZikge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZSBmaWx0ZXIgbGV2ZWwgaXMgJyMnLCB0aGlzIGlzIGEgbWF0Y2ggbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgLy8gdGhlIHRvcGljIGlzIHVuZGVmaW5lZCBvbiB0aGlzIGxldmVsIG9yIG5vdCAoJyMnIG1hdGNoZXMgcGFyZW50IGVsZW1lbnQgYXMgd2VsbCEpLlxuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGUgZmlsdGVyIGxldmVsIGlzICcrJywgd2Ugc2hhbGwgZGl2ZSBpbnRvIHRoZSByZWN1cnNpb24gb25seSBpZiB0IGlzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgIHJldHVybiB0ID8gbWF0Y2goKSA6IGZhbHNlO1xuICAgICAgICAvLyBJbiBhbGwgb3RoZXIgY2FzZXMgdGhlIGZpbHRlciBsZXZlbCBtdXN0IG1hdGNoIHRoZSB0b3BpYyBsZXZlbCxcbiAgICAgICAgLy8gYm90aCBtdXN0IGJlIGRlZmluZWQgYW5kIHRoZSBmaWx0ZXIgdGFpbCBtdXN0IG1hdGNoIHRoZSB0b3BpY1xuICAgICAgICAvLyB0YWlsICh3aGljaCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSByZWN1cnNpdmUgY2FsbCBvZiBtYXRjaCgpKS5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZiA9PT0gdCAmJiAoZiA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG1hdGNoKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG1hdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogY29ubmVjdCBtYW51YWxseSBjb25uZWN0cyB0byB0aGUgbXF0dCBicm9rZXIuXG4gICAqL1xuICBwdWJsaWMgY29ubmVjdChvcHRzPzogSU1xdHRTZXJ2aWNlT3B0aW9ucywgY2xpZW50PzogTXF0dENsaWVudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBleHRlbmQodGhpcy5vcHRpb25zIHx8IHt9LCBvcHRzKTtcbiAgICBjb25zdCBwcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgfHwgJ3dzJztcbiAgICBjb25zdCBob3N0bmFtZSA9IG9wdGlvbnMuaG9zdG5hbWUgfHwgJ2xvY2FsaG9zdCc7XG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSBvcHRpb25zLnVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXJsID0gYCR7cHJvdG9jb2x9Oi8vJHtob3N0bmFtZX1gO1xuICAgICAgdGhpcy5fdXJsICs9IG9wdGlvbnMucG9ydCA/IGA6JHtvcHRpb25zLnBvcnR9YCA6ICcnO1xuICAgICAgdGhpcy5fdXJsICs9IG9wdGlvbnMucGF0aCA/IGAke29wdGlvbnMucGF0aH1gIDogJyc7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubmV4dChNcXR0Q29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkcpO1xuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBleHRlbmQoe1xuICAgICAgY2xpZW50SWQ6IHRoaXMuX2NsaWVudElkLFxuICAgICAgcmVjb25uZWN0UGVyaW9kOiB0aGlzLl9yZWNvbm5lY3RQZXJpb2QsXG4gICAgICBjb25uZWN0VGltZW91dDogdGhpcy5fY29ubmVjdFRpbWVvdXRcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLmNsaWVudCkge1xuICAgICAgdGhpcy5jbGllbnQuZW5kKHRydWUpO1xuICAgIH1cblxuICAgIGlmICghY2xpZW50KSB7XG4gICAgICB0aGlzLmNsaWVudCA9IGNvbm5lY3QodGhpcy5fdXJsLCBtZXJnZWRPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIHRoaXMuX2NsaWVudElkID0gbWVyZ2VkT3B0aW9ucy5jbGllbnRJZDtcblxuICAgIHRoaXMuY2xpZW50Lm9uKCdjb25uZWN0JywgdGhpcy5faGFuZGxlT25Db25uZWN0KTtcbiAgICB0aGlzLmNsaWVudC5vbigncmVjb25uZWN0JywgdGhpcy5faGFuZGxlT25SZWNvbm5lY3QpO1xuICAgIHRoaXMuY2xpZW50Lm9uKCdjbG9zZScsIHRoaXMuX2hhbmRsZU9uQ2xvc2UpO1xuICAgIHRoaXMuY2xpZW50Lm9uKCdvZmZsaW5lJywgdGhpcy5faGFuZGxlT25PZmZsaW5lKTtcbiAgICB0aGlzLmNsaWVudC5vbignZXJyb3InLCB0aGlzLl9oYW5kbGVPbkVycm9yKTtcbiAgICAodGhpcy5jbGllbnQgYXMgYW55KS5zdHJlYW0ub24oJ2Vycm9yJywgdGhpcy5faGFuZGxlT25FcnJvcik7XG4gICAgdGhpcy5jbGllbnQub24oJ2VuZCcsIHRoaXMuX2hhbmRsZU9uRW5kKTtcbiAgICB0aGlzLmNsaWVudC5vbignbWVzc2FnZScsIHRoaXMuX2hhbmRsZU9uTWVzc2FnZSk7XG4gICAgdGhpcy5jbGllbnQub24oJ3BhY2tldHNlbmQnLCB0aGlzLl9oYW5kbGVPblBhY2tldHNlbmQpO1xuICAgIHRoaXMuY2xpZW50Lm9uKCdwYWNrZXRyZWNlaXZlJywgdGhpcy5faGFuZGxlT25QYWNrZXRyZWNlaXZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkaXNjb25uZWN0IGRpc2Nvbm5lY3RzIGZyb20gdGhlIG1xdHQgY2xpZW50LlxuICAgKiBUaGlzIG1ldGhvZCBgc2hvdWxkYCBiZSBleGVjdXRlZCB3aGVuIGxlYXZpbmcgdGhlIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgcHVibGljIGRpc2Nvbm5lY3QoZm9yY2UgPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtcXR0IGNsaWVudCBub3QgY29ubmVjdGVkJyk7XG4gICAgfVxuICAgIHRoaXMuY2xpZW50LmVuZChmb3JjZSk7XG4gIH1cblxuICAvKipcbiAgICogV2l0aCB0aGlzIG1ldGhvZCwgeW91IGNhbiBvYnNlcnZlIG1lc3NhZ2VzIGZvciBhIG1xdHQgdG9waWMuXG4gICAqIFRoZSBvYnNlcnZhYmxlIHdpbGwgb25seSBlbWl0IG1lc3NhZ2VzIG1hdGNoaW5nIHRoZSBmaWx0ZXIuXG4gICAqIFRoZSBmaXJzdCBvbmUgc3Vic2NyaWJpbmcgdG8gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIGV4ZWN1dGVzIGEgbXF0dCBzdWJzY3JpYmUuXG4gICAqIFRoZSBsYXN0IG9uZSB1bnN1YnNjcmliaW5nIHRoaXMgZmlsdGVyIGV4ZWN1dGVzIGEgbXF0dCB1bnN1YnNjcmliZS5cbiAgICogRXZlcnkgbmV3IHN1YnNjcmliZXIgZ2V0cyB0aGUgbGF0ZXN0IG1lc3NhZ2UuXG4gICAqL1xuICBwdWJsaWMgb2JzZXJ2ZVJldGFpbmVkKGZpbHRlclN0cmluZzogc3RyaW5nLCBvcHRzOiBJQ2xpZW50U3Vic2NyaWJlT3B0aW9ucyA9IHtxb3M6IDF9KTogT2JzZXJ2YWJsZTxJTXF0dE1lc3NhZ2U+IHtcbiAgICByZXR1cm4gdGhpcy5fZ2VuZXJhbE9ic2VydmUoZmlsdGVyU3RyaW5nLCAoKSA9PiBwdWJsaXNoUmVwbGF5KDEpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaXRoIHRoaXMgbWV0aG9kLCB5b3UgY2FuIG9ic2VydmUgbWVzc2FnZXMgZm9yIGEgbXF0dCB0b3BpYy5cbiAgICogVGhlIG9ic2VydmFibGUgd2lsbCBvbmx5IGVtaXQgbWVzc2FnZXMgbWF0Y2hpbmcgdGhlIGZpbHRlci5cbiAgICogVGhlIGZpcnN0IG9uZSBzdWJzY3JpYmluZyB0byB0aGUgcmVzdWx0aW5nIG9ic2VydmFibGUgZXhlY3V0ZXMgYSBtcXR0IHN1YnNjcmliZS5cbiAgICogVGhlIGxhc3Qgb25lIHVuc3Vic2NyaWJpbmcgdGhpcyBmaWx0ZXIgZXhlY3V0ZXMgYSBtcXR0IHVuc3Vic2NyaWJlLlxuICAgKi9cbiAgcHVibGljIG9ic2VydmUoZmlsdGVyU3RyaW5nOiBzdHJpbmcsIG9wdHM6IElDbGllbnRTdWJzY3JpYmVPcHRpb25zID0ge3FvczogMX0pOiBPYnNlcnZhYmxlPElNcXR0TWVzc2FnZT4ge1xuICAgIHJldHVybiB0aGlzLl9nZW5lcmFsT2JzZXJ2ZShmaWx0ZXJTdHJpbmcsICgpID0+IHB1Ymxpc2goKSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogV2l0aCB0aGlzIG1ldGhvZCwgeW91IGNhbiBvYnNlcnZlIG1lc3NhZ2VzIGZvciBhIG1xdHQgdG9waWMuXG4gICAqIFRoZSBvYnNlcnZhYmxlIHdpbGwgb25seSBlbWl0IG1lc3NhZ2VzIG1hdGNoaW5nIHRoZSBmaWx0ZXIuXG4gICAqIFRoZSBmaXJzdCBvbmUgc3Vic2NyaWJpbmcgdG8gdGhlIHJlc3VsdGluZyBvYnNlcnZhYmxlIGV4ZWN1dGVzIGEgbXF0dCBzdWJzY3JpYmUuXG4gICAqIFRoZSBsYXN0IG9uZSB1bnN1YnNjcmliaW5nIHRoaXMgZmlsdGVyIGV4ZWN1dGVzIGEgbXF0dCB1bnN1YnNjcmliZS5cbiAgICogRGVwZW5kaW5nIG9uIHRoZSBwdWJsaXNoIGZ1bmN0aW9uLCB0aGUgbWVzc2FnZXMgd2lsbCBlaXRoZXIgYmUgcmVwbGF5ZWQgYWZ0ZXIgbmV3XG4gICAqIHN1YnNjcmliZXJzIHN1YnNjcmliZSBvciB0aGUgbWVzc2FnZXMgYXJlIGp1c3QgcGFzc2VkIHRocm91Z2hcbiAgICovXG4gIHByaXZhdGUgX2dlbmVyYWxPYnNlcnZlKGZpbHRlclN0cmluZzogc3RyaW5nLCBwdWJsaXNoRm46IEZ1bmN0aW9uLCBvcHRzOiBJQ2xpZW50U3Vic2NyaWJlT3B0aW9ucyk6IE9ic2VydmFibGU8SU1xdHRNZXNzYWdlPiB7XG4gICAgaWYgKCF0aGlzLmNsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtcXR0IGNsaWVudCBub3QgY29ubmVjdGVkJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5vYnNlcnZhYmxlc1tmaWx0ZXJTdHJpbmddKSB7XG4gICAgICBjb25zdCByZWplY3RlZDogU3ViamVjdDxJTXF0dE1lc3NhZ2U+ID0gbmV3IFN1YmplY3QoKTtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZXNbZmlsdGVyU3RyaW5nXSA9IHVzaW5nKFxuICAgICAgICAvLyByZXNvdXJjZUZhY3Rvcnk6IERvIHRoZSBhY3R1YWwgcmVmLWNvdW50aW5nIE1RVFQgc3Vic2NyaXB0aW9uLlxuICAgICAgICAvLyByZWZjb3VudCBpcyBkZWNyZWFzZWQgb24gdW5zdWJzY3JpYmUuXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICB0aGlzLmNsaWVudC5zdWJzY3JpYmUoZmlsdGVyU3RyaW5nLCBvcHRzLCAoZXJyLCBncmFudGVkOiBJU3Vic2NyaXB0aW9uR3JhbnRbXSkgPT4ge1xuICAgICAgICAgICAgaWYgKGdyYW50ZWQpIHsgLy8gZ3JhbnRlZCBjYW4gYmUgdW5kZWZpbmVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0aW5nXG4gICAgICAgICAgICAgIGdyYW50ZWQuZm9yRWFjaCgoZ3JhbnRlZF86IElTdWJzY3JpcHRpb25HcmFudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChncmFudGVkXy5xb3MgPT09IDEyOCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2YWJsZXNbZ3JhbnRlZF8udG9waWNdO1xuICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQudW5zdWJzY3JpYmUoZ3JhbnRlZF8udG9waWMpO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWQuZXJyb3IoYHN1YnNjcmlwdGlvbiBmb3IgJyR7Z3JhbnRlZF8udG9waWN9JyByZWplY3RlZCFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdWJhY2suZW1pdCh7ZmlsdGVyOiBmaWx0ZXJTdHJpbmcsIGdyYW50ZWQ6IGdyYW50ZWRfLnFvcyAhPT0gMTI4fSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2YWJsZXNbZmlsdGVyU3RyaW5nXTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LnVuc3Vic2NyaWJlKGZpbHRlclN0cmluZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gb2JzZXJ2YWJsZUZhY3Rvcnk6IENyZWF0ZSB0aGUgb2JzZXJ2YWJsZSB0aGF0IGlzIGNvbnN1bWVkIGZyb20uXG4gICAgICAgIC8vIFRoaXMgcGFydCBpcyBub3QgZXhlY3V0ZWQgdW50aWwgdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgYnlcbiAgICAgICAgLy8gYG9ic2VydmVgIGdldHMgYWN0dWFsbHkgc3Vic2NyaWJlZC5cbiAgICAgICAgKHN1YnNjcmlwdGlvbjogVW5zdWJzY3JpYmFibGUgfCB2b2lkKSA9PiBtZXJnZShyZWplY3RlZCwgdGhpcy5tZXNzYWdlcykpXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIGZpbHRlcigobXNnOiBJTXF0dE1lc3NhZ2UpID0+IE1xdHRTZXJ2aWNlLmZpbHRlck1hdGNoZXNUb3BpYyhmaWx0ZXJTdHJpbmcsIG1zZy50b3BpYykpLFxuICAgICAgICAgIHB1Ymxpc2hGbigpLFxuICAgICAgICAgIHJlZkNvdW50KClcbiAgICAgICAgKSBhcyBPYnNlcnZhYmxlPElNcXR0TWVzc2FnZT47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9ic2VydmFibGVzW2ZpbHRlclN0cmluZ107XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYnNlcnZhYmxlIGZvciBhIHRvcGljIHdpdGggb3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQWZ0ZXIgc3Vic2NyaWJpbmcsIHRoZSBhY3R1YWwgbXF0dCBwdWJsaWNhdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGFuZFxuICAgKiB0aGUgb2JzZXJ2YWJsZSB3aWxsIGVtaXQgYW4gZW1wdHkgdmFsdWUgYW5kIGNvbXBsZXRlcywgaWYgcHVibGlzaGluZyB3YXMgc3VjY2Vzc2Z1bFxuICAgKiBvciB0aHJvd3MgYW4gZXJyb3IsIGlmIHRoZSBwdWJsaWNhdGlvbiBmYWlscy5cbiAgICovXG4gIHB1YmxpYyBwdWJsaXNoKHRvcGljOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlciwgb3B0aW9uczogSUNsaWVudFB1Ymxpc2hPcHRpb25zID0ge30pOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuY2xpZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21xdHQgY2xpZW50IG5vdCBjb25uZWN0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnM6IE9ic2VydmVyPHZvaWQ+KSA9PiB7XG4gICAgICB0aGlzLmNsaWVudC5wdWJsaXNoKHRvcGljLCBtZXNzYWdlLCBvcHRpb25zLCAoZXJyb3I6IEVycm9yfHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBvYnMuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9icy5uZXh0KG51bGwpO1xuICAgICAgICAgIG9icy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBwdWJsaXNoZXMgYSBtZXNzYWdlIGZvciBhIHRvcGljIHdpdGggb3B0aW9uYWwgb3B0aW9ucy5cbiAgICogSWYgYW4gZXJyb3Igb2NjdXJzLCBpdCB3aWxsIHRocm93LlxuICAgKi9cbiAgcHVibGljIHVuc2FmZVB1Ymxpc2godG9waWM6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBvcHRpb25zOiBJUHVibGlzaE9wdGlvbnMgPSB7fSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jbGllbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXF0dCBjbGllbnQgbm90IGNvbm5lY3RlZCcpO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudC5wdWJsaXNoKHRvcGljLCBtZXNzYWdlLCBvcHRpb25zLCAoZXJyb3I6IEVycm9yfHVuZGVmaW5lZCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVPbkNvbm5lY3QgPSAoZTogSU9uQ29ubmVjdEV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25uZWN0T25DcmVhdGUgPT09IHRydWUpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub2JzZXJ2YWJsZXMpLmZvckVhY2goKGZpbHRlclN0cmluZzogc3RyaW5nKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50LnN1YnNjcmliZShmaWx0ZXJTdHJpbmcpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubmV4dChNcXR0Q29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCk7XG4gICAgdGhpcy5fb25Db25uZWN0LmVtaXQoZSk7XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVPblJlY29ubmVjdCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbm5lY3RPbkNyZWF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5vYnNlcnZhYmxlcykuZm9yRWFjaCgoZmlsdGVyU3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQuc3Vic2NyaWJlKGZpbHRlclN0cmluZyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5uZXh0KE1xdHRDb25uZWN0aW9uU3RhdGUuQ09OTkVDVElORyk7XG4gICAgdGhpcy5fb25SZWNvbm5lY3QuZW1pdCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlT25DbG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLnN0YXRlLm5leHQoTXF0dENvbm5lY3Rpb25TdGF0ZS5DTE9TRUQpO1xuICAgIHRoaXMuX29uQ2xvc2UuZW1pdCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlT25PZmZsaW5lID0gKCkgPT4ge1xuICAgIHRoaXMuX29uT2ZmbGluZS5lbWl0KCk7XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVPbkVycm9yID0gKGU6IElPbkVycm9yRXZlbnQpID0+IHtcbiAgICB0aGlzLl9vbkVycm9yLmVtaXQoZSk7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZU9uRW5kID0gKCkgPT4ge1xuICAgIHRoaXMuX29uRW5kLmVtaXQoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZU9uTWVzc2FnZSA9ICh0b3BpYzogc3RyaW5nLCBwYXlsb2FkOiBCdWZmZXIsIHBhY2tldDogUGFja2V0KSA9PiB7XG4gICAgdGhpcy5fb25NZXNzYWdlLmVtaXQocGFja2V0KTtcbiAgICBpZiAocGFja2V0LmNtZCA9PT0gJ3B1Ymxpc2gnKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VzLm5leHQocGFja2V0IGFzIGFueSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlT25QYWNrZXRzZW5kID0gKGU6IElPblBhY2tldHNlbmRFdmVudCkgPT4ge1xuICAgIHRoaXMuX29uUGFja2V0c2VuZC5lbWl0KCk7XG4gIH1cblxuICBwcml2YXRlIF9oYW5kbGVPblBhY2tldHJlY2VpdmUgPSAoZTogSU9uUGFja2V0cmVjZWl2ZUV2ZW50KSA9PiB7XG4gICAgdGhpcy5fb25QYWNrZXRyZWNlaXZlLmVtaXQoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2dlbmVyYXRlQ2xpZW50SWQoKSB7XG4gICAgcmV0dXJuICdjbGllbnQtJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCAxOSk7XG4gIH1cbn1cbiJdfQ==