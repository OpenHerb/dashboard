{"version":3,"file":"ngx-mqtt.umd.js","sources":["../../../projects/ngx-mqtt/src/lib/mqtt.model.ts","../../../projects/ngx-mqtt/src/lib/mqtt.module.ts","../../../projects/ngx-mqtt/src/lib/mqtt.service.ts","../../../projects/ngx-mqtt/src/public-api.ts","../../../projects/ngx-mqtt/src/ngx-mqtt.ts"],"sourcesContent":["import { Stream } from 'stream';\nimport { MqttClient, IClientOptions, IClientPublishOptions, IPacket } from 'mqtt-browser';\n\nexport enum MqttConnectionState {\n  CLOSED,\n  CONNECTING,\n  CONNECTED\n}\n\nexport interface IMqttServiceOptions extends IClientOptions {\n  /**\n   * whether a new connection should be created\n   * on creating an instance of the service\n   */\n  connectOnCreate?: boolean;\n  /** the hostname of the mqtt broker */\n  hostname?: string;\n  /** the port to connect with websocket to the broker */\n  port?: number;\n  /** the path parameters to connect to e.g. `/mqtt` */\n  path?: string;\n  protocol?: 'wss' | 'ws';\n  /** if the url is provided, hostname, port path and protocol are ignored */\n  url?: string;\n}\n\nexport interface IMqttMessage extends IPacket {\n  /** the mqtt topic to which this message was published to */\n  topic: string;\n  /** the payload */\n  payload: Uint8Array;\n  /** the quality of service */\n  qos: number;\n  /** if this message is a retained message */\n  retain: boolean;\n  /** if this message is a duplicate */\n  dup: boolean;\n}\n\nexport interface IPublishOptions extends IClientPublishOptions { }\nexport interface IOnConnectEvent extends IMqttMessage { }\nexport interface IOnErrorEvent extends Error {\n  type?: string;\n}\nexport interface IOnMessageEvent extends IMqttMessage { }\nexport interface IOnSubackEvent {\n  granted: boolean;\n  filter: string;\n}\n\nexport interface IMqttClient extends MqttClient {\n  stream: Stream;\n}\n\nexport interface IOnPacketsendEvent extends IPacket { }\nexport interface IOnPacketreceiveEvent extends IPacket { }\n","import {\n  NgModule,\n  ModuleWithProviders,\n  InjectionToken\n} from '@angular/core';\nimport { IMqttClient, IMqttServiceOptions } from './mqtt.model';\n\nexport const MQTT_SERVICE_OPTIONS: IMqttServiceOptions = {\n  connectOnCreate: true,\n  hostname: 'localhost',\n  port: 1884,\n  path: ''\n};\n\nexport const MqttServiceConfig = new InjectionToken<IMqttServiceOptions>('NgxMqttServiceConfig');\nexport const MqttClientService = new InjectionToken<IMqttClient>('NgxMqttClientService');\n\n@NgModule()\nexport class MqttModule {\n  static forRoot(config: IMqttServiceOptions, client?: IMqttClient): ModuleWithProviders<MqttModule> {\n    return {\n      ngModule: MqttModule,\n      providers: [\n        {\n          provide: MqttServiceConfig,\n          useValue: config\n        },\n        {\n          provide: MqttClientService,\n          useValue: client\n        }\n      ]\n    };\n  }\n}\n","import {EventEmitter, Inject, Injectable} from '@angular/core';\nimport { connect, IClientPublishOptions, IClientSubscribeOptions, ISubscriptionGrant, MqttClient } from 'mqtt-browser';\nimport { Packet } from 'mqtt-packet';\nimport * as extend from 'xtend';\n\nimport {BehaviorSubject, merge, Observable, Observer, Subject, Subscription, Unsubscribable, using} from 'rxjs';\nimport {filter, publish, publishReplay, refCount} from 'rxjs/operators';\n\nimport {\n  IMqttMessage,\n  IMqttServiceOptions,\n  IOnConnectEvent,\n  IOnErrorEvent,\n  IOnPacketreceiveEvent,\n  IOnPacketsendEvent,\n  IOnSubackEvent,\n  IPublishOptions,\n  MqttConnectionState\n} from './mqtt.model';\n\nimport {MqttClientService, MqttServiceConfig} from './mqtt.module';\n\n/**\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\n * to only subscribe to the broker once per MQTT filter.\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class MqttService {\n\n  /**\n   * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\n   * options to configure behavior of this service, like if the connection to the broker\n   * should be established on creation of this service or not.\n   */\n  constructor(\n    @Inject(MqttServiceConfig) private options: IMqttServiceOptions,\n    @Inject(MqttClientService) private client?: MqttClient\n  ) {\n    if (options.connectOnCreate !== false) {\n      this.connect({}, client);\n    }\n\n    this.state.subscribe();\n  }\n\n  /**\n   * gets the _clientId\n   */\n  public get clientId() {\n    return this._clientId;\n  }\n\n  /** An EventEmitter to listen to connect messages */\n  public get onConnect(): EventEmitter<IOnConnectEvent> {\n    return this._onConnect;\n  }\n\n  /** An EventEmitter to listen to reconnect messages */\n  public get onReconnect(): EventEmitter<void> {\n    return this._onReconnect;\n  }\n\n  /** An EventEmitter to listen to close messages */\n  public get onClose(): EventEmitter<void> {\n    return this._onClose;\n  }\n\n  /** An EventEmitter to listen to offline events */\n  public get onOffline(): EventEmitter<void> {\n    return this._onOffline;\n  }\n\n  /** An EventEmitter to listen to error events */\n  public get onError(): EventEmitter<IOnErrorEvent> {\n    return this._onError;\n  }\n\n  /** An EventEmitter to listen to close messages */\n  public get onEnd(): EventEmitter<void> {\n    return this._onEnd;\n  }\n\n  /** An EventEmitter to listen to message events */\n  public get onMessage(): EventEmitter<Packet> {\n    return this._onMessage;\n  }\n\n  /** An EventEmitter to listen to packetsend messages */\n  public get onPacketsend(): EventEmitter<IOnPacketsendEvent> {\n    return this._onPacketsend;\n  }\n\n  /** An EventEmitter to listen to packetreceive messages */\n  public get onPacketreceive(): EventEmitter<IOnPacketreceiveEvent> {\n    return this._onPacketreceive;\n  }\n\n  /** An EventEmitter to listen to suback events */\n  public get onSuback(): EventEmitter<IOnSubackEvent> {\n    return this._onSuback;\n  }\n  /** a map of all mqtt observables by filter */\n  public observables: { [filterString: string]: Observable<IMqttMessage> } = {};\n  /** the connection state */\n  public state: Subject<MqttConnectionState> = new BehaviorSubject<MqttConnectionState>(MqttConnectionState.CLOSED);\n  /** an observable of the last mqtt message */\n  public messages: Subject<IMqttMessage> = new Subject<IMqttMessage>();\n\n  private _clientId = this._generateClientId();\n  private _connectTimeout = 10000;\n  private _reconnectPeriod = 10000;\n  private _url: string | undefined = undefined;\n\n  private _onConnect: EventEmitter<IOnConnectEvent> = new EventEmitter<IOnConnectEvent>();\n  private _onReconnect: EventEmitter<void> = new EventEmitter<void>();\n  private _onClose: EventEmitter<void> = new EventEmitter<void>();\n  private _onOffline: EventEmitter<void> = new EventEmitter<void>();\n  private _onError: EventEmitter<IOnErrorEvent> = new EventEmitter<IOnErrorEvent>();\n  private _onEnd: EventEmitter<void> = new EventEmitter<void>();\n  private _onMessage: EventEmitter<Packet> = new EventEmitter<Packet>();\n  private _onSuback: EventEmitter<IOnSubackEvent> = new EventEmitter<IOnSubackEvent>();\n  private _onPacketsend: EventEmitter<IOnPacketsendEvent> = new EventEmitter<IOnPacketsendEvent>();\n  private _onPacketreceive: EventEmitter<IOnPacketreceiveEvent> = new EventEmitter<IOnPacketreceiveEvent>();\n\n  /**\n   * This static method shall be used to determine whether a MQTT\n   * topic matches a given filter. The matching rules are specified in the MQTT\n   * standard documentation and in the library test suite.\n   *\n   * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\n   * @param  {string}  topic  A topic may not contain wildcards.\n   * @return {boolean}        true on match and false otherwise.\n   */\n  public static filterMatchesTopic(filterString: string, topic: string): boolean {\n    if (filterString[0] === '#' && topic[0] === '$') {\n      return false;\n    }\n    // Preparation: split and reverse on '/'. The JavaScript split function is sane.\n    const fs = (filterString || '').split('/').reverse();\n    const ts = (topic || '').split('/').reverse();\n    // This function is tail recursive and compares both arrays one element at a time.\n    const match = (): boolean => {\n      // Cutting of the last element of both the filter and the topic using pop().\n      const f = fs.pop();\n      const t = ts.pop();\n      switch (f) {\n        // In case the filter level is '#', this is a match no matter whether\n        // the topic is undefined on this level or not ('#' matches parent element as well!).\n        case '#':\n          return true;\n        // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.\n        case '+':\n          return t ? match() : false;\n        // In all other cases the filter level must match the topic level,\n        // both must be defined and the filter tail must match the topic\n        // tail (which is determined by the recursive call of match()).\n        default:\n          return f === t && (f === undefined ? true : match());\n      }\n    };\n    return match();\n  }\n\n  /**\n   * connect manually connects to the mqtt broker.\n   */\n  public connect(opts?: IMqttServiceOptions, client?: MqttClient) {\n    const options = extend(this.options || {}, opts);\n    const protocol = options.protocol || 'ws';\n    const hostname = options.hostname || 'localhost';\n    if (options.url) {\n      this._url = options.url;\n    } else {\n      this._url = `${protocol}://${hostname}`;\n      this._url += options.port ? `:${options.port}` : '';\n      this._url += options.path ? `${options.path}` : '';\n    }\n    this.state.next(MqttConnectionState.CONNECTING);\n    const mergedOptions = extend({\n      clientId: this._clientId,\n      reconnectPeriod: this._reconnectPeriod,\n      connectTimeout: this._connectTimeout\n    }, options);\n\n    if (this.client) {\n      this.client.end(true);\n    }\n\n    if (!client) {\n      this.client = connect(this._url, mergedOptions);\n    } else {\n      this.client = client;\n    }\n    this._clientId = mergedOptions.clientId;\n\n    this.client.on('connect', this._handleOnConnect);\n    this.client.on('reconnect', this._handleOnReconnect);\n    this.client.on('close', this._handleOnClose);\n    this.client.on('offline', this._handleOnOffline);\n    this.client.on('error', this._handleOnError);\n    (this.client as any).stream.on('error', this._handleOnError);\n    this.client.on('end', this._handleOnEnd);\n    this.client.on('message', this._handleOnMessage);\n    this.client.on('packetsend', this._handleOnPacketsend);\n    this.client.on('packetreceive', this._handleOnPacketreceive);\n  }\n\n  /**\n   * disconnect disconnects from the mqtt client.\n   * This method `should` be executed when leaving the application.\n   */\n  public disconnect(force = true) {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    this.client.end(force);\n  }\n\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   * Every new subscriber gets the latest message.\n   */\n  public observeRetained(filterString: string, opts: IClientSubscribeOptions = {qos: 1}): Observable<IMqttMessage> {\n    return this._generalObserve(filterString, () => publishReplay(1), opts);\n  }\n\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   */\n  public observe(filterString: string, opts: IClientSubscribeOptions = {qos: 1}): Observable<IMqttMessage> {\n    return this._generalObserve(filterString, () => publish(), opts);\n  }\n\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   * Depending on the publish function, the messages will either be replayed after new\n   * subscribers subscribe or the messages are just passed through\n   */\n  private _generalObserve(filterString: string, publishFn: Function, opts: IClientSubscribeOptions): Observable<IMqttMessage> {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    if (!this.observables[filterString]) {\n      const rejected: Subject<IMqttMessage> = new Subject();\n      this.observables[filterString] = using(\n        // resourceFactory: Do the actual ref-counting MQTT subscription.\n        // refcount is decreased on unsubscribe.\n        () => {\n          const subscription: Subscription = new Subscription();\n          this.client.subscribe(filterString, opts, (err, granted: ISubscriptionGrant[]) => {\n            if (granted) { // granted can be undefined when an error occurs when the client is disconnecting\n              granted.forEach((granted_: ISubscriptionGrant) => {\n                if (granted_.qos === 128) {\n                  delete this.observables[granted_.topic];\n                  this.client.unsubscribe(granted_.topic);\n                  rejected.error(`subscription for '${granted_.topic}' rejected!`);\n                }\n                this._onSuback.emit({filter: filterString, granted: granted_.qos !== 128});\n              });\n            }\n          });\n          subscription.add(() => {\n            delete this.observables[filterString];\n            this.client.unsubscribe(filterString);\n          });\n          return subscription;\n        },\n        // observableFactory: Create the observable that is consumed from.\n        // This part is not executed until the Observable returned by\n        // `observe` gets actually subscribed.\n        (subscription: Unsubscribable | void) => merge(rejected, this.messages))\n        .pipe(\n          filter((msg: IMqttMessage) => MqttService.filterMatchesTopic(filterString, msg.topic)),\n          publishFn(),\n          refCount()\n        ) as Observable<IMqttMessage>;\n    }\n    return this.observables[filterString];\n  }\n\n  /**\n   * This method returns an observable for a topic with optional options.\n   * After subscribing, the actual mqtt publication will be executed and\n   * the observable will emit an empty value and completes, if publishing was successful\n   * or throws an error, if the publication fails.\n   */\n  public publish(topic: string, message: string | Buffer, options: IClientPublishOptions = {}): Observable<void> {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    return Observable.create((obs: Observer<void>) => {\n      this.client.publish(topic, message, options, (error: Error|undefined) => {\n        if (error) {\n          obs.error(error);\n        } else {\n          obs.next(null);\n          obs.complete();\n        }\n      });\n    });\n  }\n\n  /**\n   * This method publishes a message for a topic with optional options.\n   * If an error occurs, it will throw.\n   */\n  public unsafePublish(topic: string, message: string | Buffer, options: IPublishOptions = {}): void {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    this.client.publish(topic, message, options, (error: Error|undefined) => {\n      if (error) {\n        throw (error);\n      }\n    });\n  }\n\n  private _handleOnConnect = (e: IOnConnectEvent) => {\n    if (this.options.connectOnCreate === true) {\n      Object.keys(this.observables).forEach((filterString: string) => {\n        this.client.subscribe(filterString);\n      });\n    }\n    this.state.next(MqttConnectionState.CONNECTED);\n    this._onConnect.emit(e);\n  }\n\n  private _handleOnReconnect = () => {\n    if (this.options.connectOnCreate === true) {\n      Object.keys(this.observables).forEach((filterString: string) => {\n        this.client.subscribe(filterString);\n      });\n    }\n    this.state.next(MqttConnectionState.CONNECTING);\n    this._onReconnect.emit();\n  }\n\n  private _handleOnClose = () => {\n    this.state.next(MqttConnectionState.CLOSED);\n    this._onClose.emit();\n  }\n\n  private _handleOnOffline = () => {\n    this._onOffline.emit();\n  }\n\n  private _handleOnError = (e: IOnErrorEvent) => {\n    this._onError.emit(e);\n    console.error(e);\n  }\n\n  private _handleOnEnd = () => {\n    this._onEnd.emit();\n  }\n\n  private _handleOnMessage = (topic: string, payload: Buffer, packet: Packet) => {\n    this._onMessage.emit(packet);\n    if (packet.cmd === 'publish') {\n      this.messages.next(packet as any);\n    }\n  }\n\n  private _handleOnPacketsend = (e: IOnPacketsendEvent) => {\n    this._onPacketsend.emit();\n  }\n\n  private _handleOnPacketreceive = (e: IOnPacketreceiveEvent) => {\n    this._onPacketreceive.emit();\n  }\n\n  private _generateClientId() {\n    return 'client-' + Math.random().toString(36).substr(2, 19);\n  }\n}\n","/*\n * Public API Surface of ngx-mqtt\n */\nexport * from './lib/mqtt.model';\nexport * from './lib/mqtt.service';\nexport * from './lib/mqtt.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["MqttConnectionState","InjectionToken","NgModule","BehaviorSubject","Subject","EventEmitter","extend","connect","publishReplay","publish","using","Subscription","merge","filter","refCount","Observable","Injectable","Inject","MqttClient"],"mappings":"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"}