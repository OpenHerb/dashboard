{"version":3,"file":"ngx-mqtt.js","sources":["../../../projects/ngx-mqtt/src/lib/mqtt.model.ts","../../../projects/ngx-mqtt/src/lib/mqtt.module.ts","../../../projects/ngx-mqtt/src/lib/mqtt.service.ts","../../../projects/ngx-mqtt/src/public-api.ts","../../../projects/ngx-mqtt/src/ngx-mqtt.ts"],"sourcesContent":["import { Stream } from 'stream';\nimport { MqttClient, IClientOptions, IClientPublishOptions, IPacket } from 'mqtt-browser';\n\nexport enum MqttConnectionState {\n  CLOSED,\n  CONNECTING,\n  CONNECTED\n}\n\nexport interface IMqttServiceOptions extends IClientOptions {\n  /**\n   * whether a new connection should be created\n   * on creating an instance of the service\n   */\n  connectOnCreate?: boolean;\n  /** the hostname of the mqtt broker */\n  hostname?: string;\n  /** the port to connect with websocket to the broker */\n  port?: number;\n  /** the path parameters to connect to e.g. `/mqtt` */\n  path?: string;\n  protocol?: 'wss' | 'ws';\n  /** if the url is provided, hostname, port path and protocol are ignored */\n  url?: string;\n}\n\nexport interface IMqttMessage extends IPacket {\n  /** the mqtt topic to which this message was published to */\n  topic: string;\n  /** the payload */\n  payload: Uint8Array;\n  /** the quality of service */\n  qos: number;\n  /** if this message is a retained message */\n  retain: boolean;\n  /** if this message is a duplicate */\n  dup: boolean;\n}\n\nexport interface IPublishOptions extends IClientPublishOptions { }\nexport interface IOnConnectEvent extends IMqttMessage { }\nexport interface IOnErrorEvent extends Error {\n  type?: string;\n}\nexport interface IOnMessageEvent extends IMqttMessage { }\nexport interface IOnSubackEvent {\n  granted: boolean;\n  filter: string;\n}\n\nexport interface IMqttClient extends MqttClient {\n  stream: Stream;\n}\n\nexport interface IOnPacketsendEvent extends IPacket { }\nexport interface IOnPacketreceiveEvent extends IPacket { }\n","import {\n  NgModule,\n  ModuleWithProviders,\n  InjectionToken\n} from '@angular/core';\nimport { IMqttClient, IMqttServiceOptions } from './mqtt.model';\n\nexport const MQTT_SERVICE_OPTIONS: IMqttServiceOptions = {\n  connectOnCreate: true,\n  hostname: 'localhost',\n  port: 1884,\n  path: ''\n};\n\nexport const MqttServiceConfig = new InjectionToken<IMqttServiceOptions>('NgxMqttServiceConfig');\nexport const MqttClientService = new InjectionToken<IMqttClient>('NgxMqttClientService');\n\n@NgModule()\nexport class MqttModule {\n  static forRoot(config: IMqttServiceOptions, client?: IMqttClient): ModuleWithProviders<MqttModule> {\n    return {\n      ngModule: MqttModule,\n      providers: [\n        {\n          provide: MqttServiceConfig,\n          useValue: config\n        },\n        {\n          provide: MqttClientService,\n          useValue: client\n        }\n      ]\n    };\n  }\n}\n","import {EventEmitter, Inject, Injectable} from '@angular/core';\nimport { connect, IClientPublishOptions, IClientSubscribeOptions, ISubscriptionGrant, MqttClient } from 'mqtt-browser';\nimport { Packet } from 'mqtt-packet';\nimport * as extend from 'xtend';\n\nimport {BehaviorSubject, merge, Observable, Observer, Subject, Subscription, Unsubscribable, using} from 'rxjs';\nimport {filter, publish, publishReplay, refCount} from 'rxjs/operators';\n\nimport {\n  IMqttMessage,\n  IMqttServiceOptions,\n  IOnConnectEvent,\n  IOnErrorEvent,\n  IOnPacketreceiveEvent,\n  IOnPacketsendEvent,\n  IOnSubackEvent,\n  IPublishOptions,\n  MqttConnectionState\n} from './mqtt.model';\n\nimport {MqttClientService, MqttServiceConfig} from './mqtt.module';\n\n/**\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\n * to only subscribe to the broker once per MQTT filter.\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class MqttService {\n\n  /**\n   * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\n   * options to configure behavior of this service, like if the connection to the broker\n   * should be established on creation of this service or not.\n   */\n  constructor(\n    @Inject(MqttServiceConfig) private options: IMqttServiceOptions,\n    @Inject(MqttClientService) private client?: MqttClient\n  ) {\n    if (options.connectOnCreate !== false) {\n      this.connect({}, client);\n    }\n\n    this.state.subscribe();\n  }\n\n  /**\n   * gets the _clientId\n   */\n  public get clientId() {\n    return this._clientId;\n  }\n\n  /** An EventEmitter to listen to connect messages */\n  public get onConnect(): EventEmitter<IOnConnectEvent> {\n    return this._onConnect;\n  }\n\n  /** An EventEmitter to listen to reconnect messages */\n  public get onReconnect(): EventEmitter<void> {\n    return this._onReconnect;\n  }\n\n  /** An EventEmitter to listen to close messages */\n  public get onClose(): EventEmitter<void> {\n    return this._onClose;\n  }\n\n  /** An EventEmitter to listen to offline events */\n  public get onOffline(): EventEmitter<void> {\n    return this._onOffline;\n  }\n\n  /** An EventEmitter to listen to error events */\n  public get onError(): EventEmitter<IOnErrorEvent> {\n    return this._onError;\n  }\n\n  /** An EventEmitter to listen to close messages */\n  public get onEnd(): EventEmitter<void> {\n    return this._onEnd;\n  }\n\n  /** An EventEmitter to listen to message events */\n  public get onMessage(): EventEmitter<Packet> {\n    return this._onMessage;\n  }\n\n  /** An EventEmitter to listen to packetsend messages */\n  public get onPacketsend(): EventEmitter<IOnPacketsendEvent> {\n    return this._onPacketsend;\n  }\n\n  /** An EventEmitter to listen to packetreceive messages */\n  public get onPacketreceive(): EventEmitter<IOnPacketreceiveEvent> {\n    return this._onPacketreceive;\n  }\n\n  /** An EventEmitter to listen to suback events */\n  public get onSuback(): EventEmitter<IOnSubackEvent> {\n    return this._onSuback;\n  }\n  /** a map of all mqtt observables by filter */\n  public observables: { [filterString: string]: Observable<IMqttMessage> } = {};\n  /** the connection state */\n  public state: Subject<MqttConnectionState> = new BehaviorSubject<MqttConnectionState>(MqttConnectionState.CLOSED);\n  /** an observable of the last mqtt message */\n  public messages: Subject<IMqttMessage> = new Subject<IMqttMessage>();\n\n  private _clientId = this._generateClientId();\n  private _connectTimeout = 10000;\n  private _reconnectPeriod = 10000;\n  private _url: string | undefined = undefined;\n\n  private _onConnect: EventEmitter<IOnConnectEvent> = new EventEmitter<IOnConnectEvent>();\n  private _onReconnect: EventEmitter<void> = new EventEmitter<void>();\n  private _onClose: EventEmitter<void> = new EventEmitter<void>();\n  private _onOffline: EventEmitter<void> = new EventEmitter<void>();\n  private _onError: EventEmitter<IOnErrorEvent> = new EventEmitter<IOnErrorEvent>();\n  private _onEnd: EventEmitter<void> = new EventEmitter<void>();\n  private _onMessage: EventEmitter<Packet> = new EventEmitter<Packet>();\n  private _onSuback: EventEmitter<IOnSubackEvent> = new EventEmitter<IOnSubackEvent>();\n  private _onPacketsend: EventEmitter<IOnPacketsendEvent> = new EventEmitter<IOnPacketsendEvent>();\n  private _onPacketreceive: EventEmitter<IOnPacketreceiveEvent> = new EventEmitter<IOnPacketreceiveEvent>();\n\n  /**\n   * This static method shall be used to determine whether a MQTT\n   * topic matches a given filter. The matching rules are specified in the MQTT\n   * standard documentation and in the library test suite.\n   *\n   * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\n   * @param  {string}  topic  A topic may not contain wildcards.\n   * @return {boolean}        true on match and false otherwise.\n   */\n  public static filterMatchesTopic(filterString: string, topic: string): boolean {\n    if (filterString[0] === '#' && topic[0] === '$') {\n      return false;\n    }\n    // Preparation: split and reverse on '/'. The JavaScript split function is sane.\n    const fs = (filterString || '').split('/').reverse();\n    const ts = (topic || '').split('/').reverse();\n    // This function is tail recursive and compares both arrays one element at a time.\n    const match = (): boolean => {\n      // Cutting of the last element of both the filter and the topic using pop().\n      const f = fs.pop();\n      const t = ts.pop();\n      switch (f) {\n        // In case the filter level is '#', this is a match no matter whether\n        // the topic is undefined on this level or not ('#' matches parent element as well!).\n        case '#':\n          return true;\n        // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.\n        case '+':\n          return t ? match() : false;\n        // In all other cases the filter level must match the topic level,\n        // both must be defined and the filter tail must match the topic\n        // tail (which is determined by the recursive call of match()).\n        default:\n          return f === t && (f === undefined ? true : match());\n      }\n    };\n    return match();\n  }\n\n  /**\n   * connect manually connects to the mqtt broker.\n   */\n  public connect(opts?: IMqttServiceOptions, client?: MqttClient) {\n    const options = extend(this.options || {}, opts);\n    const protocol = options.protocol || 'ws';\n    const hostname = options.hostname || 'localhost';\n    if (options.url) {\n      this._url = options.url;\n    } else {\n      this._url = `${protocol}://${hostname}`;\n      this._url += options.port ? `:${options.port}` : '';\n      this._url += options.path ? `${options.path}` : '';\n    }\n    this.state.next(MqttConnectionState.CONNECTING);\n    const mergedOptions = extend({\n      clientId: this._clientId,\n      reconnectPeriod: this._reconnectPeriod,\n      connectTimeout: this._connectTimeout\n    }, options);\n\n    if (this.client) {\n      this.client.end(true);\n    }\n\n    if (!client) {\n      this.client = connect(this._url, mergedOptions);\n    } else {\n      this.client = client;\n    }\n    this._clientId = mergedOptions.clientId;\n\n    this.client.on('connect', this._handleOnConnect);\n    this.client.on('reconnect', this._handleOnReconnect);\n    this.client.on('close', this._handleOnClose);\n    this.client.on('offline', this._handleOnOffline);\n    this.client.on('error', this._handleOnError);\n    (this.client as any).stream.on('error', this._handleOnError);\n    this.client.on('end', this._handleOnEnd);\n    this.client.on('message', this._handleOnMessage);\n    this.client.on('packetsend', this._handleOnPacketsend);\n    this.client.on('packetreceive', this._handleOnPacketreceive);\n  }\n\n  /**\n   * disconnect disconnects from the mqtt client.\n   * This method `should` be executed when leaving the application.\n   */\n  public disconnect(force = true) {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    this.client.end(force);\n  }\n\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   * Every new subscriber gets the latest message.\n   */\n  public observeRetained(filterString: string, opts: IClientSubscribeOptions = {qos: 1}): Observable<IMqttMessage> {\n    return this._generalObserve(filterString, () => publishReplay(1), opts);\n  }\n\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   */\n  public observe(filterString: string, opts: IClientSubscribeOptions = {qos: 1}): Observable<IMqttMessage> {\n    return this._generalObserve(filterString, () => publish(), opts);\n  }\n\n  /**\n   * With this method, you can observe messages for a mqtt topic.\n   * The observable will only emit messages matching the filter.\n   * The first one subscribing to the resulting observable executes a mqtt subscribe.\n   * The last one unsubscribing this filter executes a mqtt unsubscribe.\n   * Depending on the publish function, the messages will either be replayed after new\n   * subscribers subscribe or the messages are just passed through\n   */\n  private _generalObserve(filterString: string, publishFn: Function, opts: IClientSubscribeOptions): Observable<IMqttMessage> {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    if (!this.observables[filterString]) {\n      const rejected: Subject<IMqttMessage> = new Subject();\n      this.observables[filterString] = using(\n        // resourceFactory: Do the actual ref-counting MQTT subscription.\n        // refcount is decreased on unsubscribe.\n        () => {\n          const subscription: Subscription = new Subscription();\n          this.client.subscribe(filterString, opts, (err, granted: ISubscriptionGrant[]) => {\n            if (granted) { // granted can be undefined when an error occurs when the client is disconnecting\n              granted.forEach((granted_: ISubscriptionGrant) => {\n                if (granted_.qos === 128) {\n                  delete this.observables[granted_.topic];\n                  this.client.unsubscribe(granted_.topic);\n                  rejected.error(`subscription for '${granted_.topic}' rejected!`);\n                }\n                this._onSuback.emit({filter: filterString, granted: granted_.qos !== 128});\n              });\n            }\n          });\n          subscription.add(() => {\n            delete this.observables[filterString];\n            this.client.unsubscribe(filterString);\n          });\n          return subscription;\n        },\n        // observableFactory: Create the observable that is consumed from.\n        // This part is not executed until the Observable returned by\n        // `observe` gets actually subscribed.\n        (subscription: Unsubscribable | void) => merge(rejected, this.messages))\n        .pipe(\n          filter((msg: IMqttMessage) => MqttService.filterMatchesTopic(filterString, msg.topic)),\n          publishFn(),\n          refCount()\n        ) as Observable<IMqttMessage>;\n    }\n    return this.observables[filterString];\n  }\n\n  /**\n   * This method returns an observable for a topic with optional options.\n   * After subscribing, the actual mqtt publication will be executed and\n   * the observable will emit an empty value and completes, if publishing was successful\n   * or throws an error, if the publication fails.\n   */\n  public publish(topic: string, message: string | Buffer, options: IClientPublishOptions = {}): Observable<void> {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    return Observable.create((obs: Observer<void>) => {\n      this.client.publish(topic, message, options, (error: Error|undefined) => {\n        if (error) {\n          obs.error(error);\n        } else {\n          obs.next(null);\n          obs.complete();\n        }\n      });\n    });\n  }\n\n  /**\n   * This method publishes a message for a topic with optional options.\n   * If an error occurs, it will throw.\n   */\n  public unsafePublish(topic: string, message: string | Buffer, options: IPublishOptions = {}): void {\n    if (!this.client) {\n      throw new Error('mqtt client not connected');\n    }\n    this.client.publish(topic, message, options, (error: Error|undefined) => {\n      if (error) {\n        throw (error);\n      }\n    });\n  }\n\n  private _handleOnConnect = (e: IOnConnectEvent) => {\n    if (this.options.connectOnCreate === true) {\n      Object.keys(this.observables).forEach((filterString: string) => {\n        this.client.subscribe(filterString);\n      });\n    }\n    this.state.next(MqttConnectionState.CONNECTED);\n    this._onConnect.emit(e);\n  }\n\n  private _handleOnReconnect = () => {\n    if (this.options.connectOnCreate === true) {\n      Object.keys(this.observables).forEach((filterString: string) => {\n        this.client.subscribe(filterString);\n      });\n    }\n    this.state.next(MqttConnectionState.CONNECTING);\n    this._onReconnect.emit();\n  }\n\n  private _handleOnClose = () => {\n    this.state.next(MqttConnectionState.CLOSED);\n    this._onClose.emit();\n  }\n\n  private _handleOnOffline = () => {\n    this._onOffline.emit();\n  }\n\n  private _handleOnError = (e: IOnErrorEvent) => {\n    this._onError.emit(e);\n    console.error(e);\n  }\n\n  private _handleOnEnd = () => {\n    this._onEnd.emit();\n  }\n\n  private _handleOnMessage = (topic: string, payload: Buffer, packet: Packet) => {\n    this._onMessage.emit(packet);\n    if (packet.cmd === 'publish') {\n      this.messages.next(packet as any);\n    }\n  }\n\n  private _handleOnPacketsend = (e: IOnPacketsendEvent) => {\n    this._onPacketsend.emit();\n  }\n\n  private _handleOnPacketreceive = (e: IOnPacketreceiveEvent) => {\n    this._onPacketreceive.emit();\n  }\n\n  private _generateClientId() {\n    return 'client-' + Math.random().toString(36).substr(2, 19);\n  }\n}\n","/*\n * Public API Surface of ngx-mqtt\n */\nexport * from './lib/mqtt.model';\nexport * from './lib/mqtt.service';\nexport * from './lib/mqtt.module';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}